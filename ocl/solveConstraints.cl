// The new Otis solver in Houdini 21 also uses VBD
// They forgot to cite their code sources though :)
#if has_otis
    // Otis has some new hessian approximations and definitions we can use here
    #include "../sim/vbd_energy.cl"
#else
    // Otis includes matrix.h, otherwise we do it manually
    #include <matrix.h>
#endif

// Constraint hash IDs, generated by constraintHash() in VEX
#define VBD_MASS_SPRING 10827462
#define VBD_NEO_HOOKEAN 1206786922
#define AVBD_SPRING -1715226869
#define AVBD_JOINT -1456250084

// Faster but memory unsafe
#define entriesAt_unsafe(_arr_, _idx_) (_arr_##_index[_idx_+1] - _arr_##_index[_idx_])
#define compAt_unsafe(_arr_, _idx_, _compidx_) _arr_[_arr_##_index[_idx_] + _compidx_]

#define entriesAt(_arr_, _idx_) ((_idx_ >= 0 && _idx_ < _arr_##_length) ? (_arr_##_index[_idx_+1] - _arr_##_index[_idx_]) : 0)
#define compAt(_arr_, _idx_, _compidx_) ((_idx_ >= 0 && _idx_ < _arr_##_length && _compidx_ >= 0 && _compidx_ < entriesAt_unsafe(_arr_, _idx_)) ? _arr_[_arr_##_index[_idx_] + _compidx_] : 0)

// Macro to load the attributes commonly used by AVBD
#define LOAD_AVBD_ATTRIBS(prim_id) \
    const fpreal3 lambda  = vload3(prim_id, _bound_lambda); \
    const fpreal3 penalty = vload3(prim_id, _bound_penalty); \
    const fpreal3 fmin    = vload3(prim_id, _bound_fmin); \
    const fpreal3 fmax    = vload3(prim_id, _bound_fmax);

// Rough approximation to match Vellum
const fpreal STIFFNESS_SCALE = 10.0f;
const fpreal DAMPING_SCALE = 0.001f;

typedef fpreal fpreal9[9];
typedef fpreal9 mat9[9];

// Prefixed in case these get added to matrix.h later
static fpreal3 _mat32vecmul(const mat32 a, const fpreal2 b)
{
    return (fpreal3)(dot(a[0], b), dot(a[1], b), dot(a[2], b));
}

static fpreal2 _mat32Tvecmul(const mat32 a, const fpreal3 b)
{
    return (fpreal2)(
        dot((fpreal3)(a[0][0], a[1][0], a[2][0]), b),
        dot((fpreal3)(a[0][1], a[1][1], a[2][1]), b)
    );
}

static void _mat3adddiag(mat3 mout, const mat3 m, const fpreal x)
{
    mout[0][0] = m[0][0] + x;
    mout[1][1] = m[1][1] + x;
    mout[2][2] = m[2][2] + x;
}

// Helps compute tangents for friction based on the surface normal
// From https://graphics.pixar.com/library/OrthonormalB/paper.pdf
static void buildOrthonormalBasis(const fpreal3 n, mat32 out)
{
    const fpreal sign = copysign(1.0f, n.z);
    const fpreal a = -1.0f / (sign + n.z);
    const fpreal b = n.x * n.y * a;
    out[0][0] = 1.0f + sign * n.x * n.x * a;
    out[1][0] = sign * b;
    out[2][0] = -sign * n.x;
    out[0][1] = b;
    out[1][1] = sign + n.y * n.y * a;
    out[2][1] = -n.y;
}

// force * invert(hessian) using LDLT decomposition
// From https://github.com/savant117/avbd-demo2d/blob/main/source/maths.h#L323
static fpreal3 solveLDLT(
    const fpreal3 force,
    const mat3 hessian)
{
    // Compute LDL^T decomposition
    const fpreal D1 = hessian[0][0];
    const fpreal L21 = hessian[1][0] / hessian[0][0];
    const fpreal L31 = hessian[2][0] / hessian[0][0];
    const fpreal D2 = hessian[1][1] - L21 * L21 * D1;
    const fpreal L32 = (hessian[2][1] - L21 * L31 * D1) / D2;
    const fpreal D3 = hessian[2][2] - (L31 * L31 * D1 + L32 * L32 * D2);

    // Forward substitution: Solve Ly = f
    const fpreal y1 = force.x;
    const fpreal y2 = force.y - L21 * y1;
    const fpreal y3 = force.z - L31 * y1 - L32 * y2;

    // Diagonal solve: Solve Dz = y
    const fpreal z1 = y1 / D1;
    const fpreal z2 = y2 / D2;
    const fpreal z3 = y3 / D3;

    // Backward substitution: Solve L^T x = z
    fpreal3 x;
    x.z = z3;
    x.y = z2 - L32 * x.z;
    x.x = z1 - L21 * x.y - L31 * x.z;

    return x;
}

// out = force * invert(hessian) with a check similar to fabs(det3(hessian)) < epsilon
// From https://github.com/AnkaChan/CuMatrix/blob/main/CuMatrix/MatrixOps/CuMatrix.h#L235
static int solveDirect(
    const fpreal3 force,
    const mat3 hessian,
    fpreal3 *out,
    const fpreal epsilon)
{
    const fpreal3 s0 = hessian[0];
    const fpreal3 s1 = hessian[1];
    const fpreal3 s2 = hessian[2];

    const fpreal3 adj0 = cross(s1, s2);
    const fpreal3 adj1 = cross(s2, s0);
    const fpreal3 adj2 = cross(s0, s1);

    const fpreal det = dot(s0, adj0);
    if (fabs(det) < epsilon * (fabs(s0.x * adj0.x) + fabs(s1.x * adj0.y) + fabs(s2.x * adj0.z))) return 0;

    *out = (fpreal3)(dot(adj0, force), dot(adj1, force), dot(adj2, force)) / det;
    return 1;
}

// Used for accelerated convergence, tends to explode. Probably will remove later
// From https://github.com/AnkaChan/TinyVBD/blob/main/main.cpp#L193
// Prefixed since this recently got added to the new Otis solver in Houdini 21
static fpreal _getAcceleratorOmega(
    const int order,
    const fpreal pho,
    const fpreal prev_omega)
{
    switch (order)
    {
        case 1:
            return 1.0f;
        case 2:
            return 2.0f / (2.0f - (pho * pho));
        default:
            return 4.0f / (4.0f - (pho * pho) * prev_omega);
    }
}

// Influence from inertia and mass. Sadly this also includes gravity, so damping also affects gravity
// From https://github.com/AnkaChan/Gaia/blob/main/Simulator/Modules/VBD/VBD_BaseMaterial.h#L359
static void accumulateInertiaForceAndHessian(
    fpreal3 *force,
    mat3 hessian,
    const fpreal mass,
    const fpreal3 P,
    const fpreal3 inertia,
    const fpreal timeinc)
{
    const fpreal scale = mass / (timeinc * timeinc);
    *force += (inertia - P) * scale;
    _mat3adddiag(hessian, hessian, scale);
}

// SPD diagonal approximation of the hessian from AVBD
// This greatly improves stability for stiff constraints, but causes issues with neo-hookean
static void spdApproximation(mat3 h)
{
    // Column norm in the diagonal
    h[0][0] = length((fpreal3)(h[0][0], h[1][0], h[2][0]));
    h[1][1] = length((fpreal3)(h[0][1], h[1][1], h[2][1]));
    h[2][2] = length((fpreal3)(h[0][2], h[1][2], h[2][2]));

    // Wipe everything else
    h[0][1] = h[0][2] = h[1][0] = h[1][2] = h[2][0] = h[2][1] = 0.0f;
}

// From https://github.com/savant117/avbd-demo2d/blob/main/source/solver.cpp#L205
static void dualUpdateAVBD(
    global fpreal *_bound_lambda,
    global fpreal *_bound_penalty,
    global int *_bound_broken,
    global fpreal *_bound_breakthreshold,
    const int used_rows,
    const int prim_id,
    const fpreal stiffness,
    const fpreal3 lambda,
    const fpreal3 penalty,
    const fpreal3 C,
    const fpreal3 fmin,
    const fpreal3 fmax,
    const fpreal beta,
    const fpreal PENALTY_MAX)
{
    fpreal3 out_lambda, out_penalty;
    for (int i = 0; i < used_rows; ++i)
    {
        // Use lambda as 0 if it's not a hard constraint
        fpreal tmp_lambda = isinf(stiffness) ? lambda[i] : 0.0f;
        
        // Update lambda (Eq 11)
        tmp_lambda = out_lambda[i] = clamp(penalty[i] * C[i] + tmp_lambda, fmin[i], fmax[i]);
        
        // Remove the constraint if it exceeds the fracture threshold
        const fpreal breakthreshold = _bound_breakthreshold[prim_id];
        if (breakthreshold >= 0.0f && fabs(tmp_lambda) >= breakthreshold)
        {
            _bound_broken[prim_id] = 1;
        }
        
        // Update the penalty parameter and clamp to material stiffness if we are within the force bounds (Eq. 16)
        if (tmp_lambda > fmin[i] && tmp_lambda < fmax[i])
        {
            // Assumes the stiffness has already been scaled by STIFFNESS_SCALE
            out_penalty[i] = min(penalty[i] + beta * fabs(C[i]), min(PENALTY_MAX, stiffness));
        }
    }
    vstore3(out_lambda, prim_id, _bound_lambda);
    vstore3(out_penalty, prim_id, _bound_penalty);
}

// From https://github.com/savant117/avbd-demo2d/blob/main/source/solver.cpp#L179
static void accumulateAVBD_Spring(
    fpreal3 *force,
    mat3 hessian,
    const fpreal3 J, // Jacobian (1st derivative)
    mat3 H, // Hessian (2nd derivative)
    const fpreal C,
    const fpreal stiffness,
    const fpreal lambda,
    const fpreal penalty,
    const fpreal fmin,
    const fpreal fmax)
{
    // Use lambda as 0 if it's not a hard constraint
    const fpreal tmp_lambda = isinf(stiffness) ? lambda : 0.0f;

    // Compute the clamped force magnitude (Sec 3.2)
    const fpreal f = clamp(penalty * C + tmp_lambda, fmin, fmax);

    // Compute the diagonally lumped geometric stiffness term (Sec 3.5)
    spdApproximation(H);

    mat3 G;
    mat3scale(G, H, fabs(f));
    outerprod3(J, J * penalty, H);
    mat3add(H, G, H);

    // Accumulate force (Eq. 13) and hessian (Eq. 17)
    *force -= J * f;
    mat3add(hessian, H, hessian);
}

// From https://github.com/savant117/avbd-demo2d/blob/main/source/spring.cpp#L22
static int computeConstraint_SpringAVBD(
    int *pt0,
    fpreal3 *d,
    fpreal *dlen,
    fpreal *C,
    const int prim_id,
    global int *_bound_primpoints,
    global int *_bound_primpoints_index,
    const int _bound_primpoints_length,
    global fpreal *_bound_P,
    global fpreal *_bound_restlength)
{
    *pt0 = compAt(_bound_primpoints, prim_id, 0);
    const int pt1 = compAt(_bound_primpoints, prim_id, 1);

    const fpreal3 p0 = vload3(*pt0, _bound_P);
    const fpreal3 p1 = vload3(pt1, _bound_P);
    
    const fpreal restlength = _bound_restlength[prim_id];

    *d = p0 - p1;
    const fpreal dlen2 = dot(*d, *d);
    if (dlen2 == 0.0f) return 0;
    *dlen = sqrt(dlen2);
    
    // C is the constraint error
    *C = *dlen - restlength;

    return 1;
}

// Energy for spring constraints from AVBD
// Should really be merged with the VBD mass-spring constraints
static void accumulateMaterialForceAndHessian_SpringAVBD(
    fpreal3 *force,
    mat3 hessian,
    const int idx,
    const int prim_id,
    global int *_bound_primpoints,
    global int *_bound_primpoints_index,
    const int _bound_primpoints_length,
    global fpreal *_bound_P,
    global fpreal* _bound_stiffness,
    global fpreal *_bound_restlength,
    global fpreal *_bound_lambda,
    global fpreal *_bound_penalty,
    global fpreal *_bound_fmin,
    global fpreal *_bound_fmax)
{
    int pt0;
    fpreal3 d;
    fpreal dlen, C;
    if (!computeConstraint_SpringAVBD(&pt0, &d, &dlen, &C,
        prim_id, _bound_primpoints, _bound_primpoints_index, _bound_primpoints_length,
        _bound_P, _bound_restlength)) return;
    
    const fpreal3 n = d / dlen;

    // This hessian isn't rotated like in avbd-2d, because @orient isn't supported yet
    mat3 H = {
        ((fpreal3)(1.0f, 0.0f, 0.0f) - (n * n.x)) / dlen,
        ((fpreal3)(0.0f, 1.0f, 0.0f) - (n * n.y)) / dlen,
        ((fpreal3)(0.0f, 0.0f, 1.0f) - (n * n.z)) / dlen
    };
    // AVBD also uses a jacobian (1st derivative)
    // VBD constraints should probably be updated to use a jacobian too
    const fpreal3 J = pt0 == idx ? n : -n;
    
    const fpreal stiffness = _bound_stiffness[prim_id] * STIFFNESS_SCALE;
    LOAD_AVBD_ATTRIBS(prim_id);
    
    accumulateAVBD_Spring(force, hessian, J, H, C, stiffness, lambda.x, penalty.x, fmin.x, fmax.x);
}

static void dualUpdate_SpringAVBD(
    const int prim_id,
    global int *_bound_primpoints,
    global int *_bound_primpoints_index,
    const int _bound_primpoints_length,
    global fpreal *_bound_P,
    global fpreal* _bound_stiffness,
    global fpreal *_bound_restlength,
    global fpreal *_bound_lambda,
    global fpreal *_bound_penalty,
    global fpreal *_bound_fmin,
    global fpreal *_bound_fmax,
    global int *_bound_broken,
    global fpreal *_bound_breakthreshold,
    const fpreal beta,
    const fpreal PENALTY_MAX)
{
    int pt0;
    fpreal3 d;
    fpreal dlen, C;
    if (!computeConstraint_SpringAVBD(&pt0, &d, &dlen, &C,
        prim_id, _bound_primpoints, _bound_primpoints_index, _bound_primpoints_length,
        _bound_P, _bound_restlength)) return;
    
    const fpreal stiffness = _bound_stiffness[prim_id] * STIFFNESS_SCALE;
    LOAD_AVBD_ATTRIBS(prim_id);

    dualUpdateAVBD(_bound_lambda, _bound_penalty, _bound_broken, _bound_breakthreshold, 1,
        prim_id, stiffness, lambda, penalty, C, fmin, fmax, beta, PENALTY_MAX);
}

// From https://github.com/savant117/avbd-demo2d/blob/main/source/solver.cpp#L179
// Simplified for joints, which have an empty hessian
static void accumulateAVBD_Joint(
    fpreal3 *force,
    mat3 hessian,
    const mat3 J, // Jacobian (1st derivative)
    const fpreal3 C,
    const fpreal stiffness,
    const fpreal3 lambda,
    const fpreal3 penalty,
    const fpreal3 fmin,
    const fpreal3 fmax)
{
    for (int i = 0; i < 3; ++i)
    {
        // Use lambda as 0 if it's not a hard constraint
        const fpreal tmp_lambda = isinf(stiffness) ? lambda[i] : 0.0f;

        // Compute the clamped force magnitude (Sec 3.2)
        const fpreal f = clamp(penalty[i] * C[i] + tmp_lambda, fmin[i], fmax[i]);
        
        // Since the hessian is empty, we only need the jacobian here
        mat3 H;
        outerprod3(J[i], J[i] * penalty[i], H);

        // Accumulate force (Eq. 13) and hessian (Eq. 17)
        *force -= J[i] * f;
        mat3add(hessian, H, hessian);
    }
}

// From https://github.com/savant117/avbd-demo2d/blob/main/source/joint.cpp#L36
static void computeConstraint_JointAVBD(
    int *pt0,
    fpreal3 *C,
    fpreal *stiffness,
    const int prim_id,
    global int *_bound_primpoints,
    global int *_bound_primpoints_index,
    const int _bound_primpoints_length,
    global fpreal *_bound_P,
    global fpreal *_bound_C,
    global fpreal *_bound_stiffness,
    const fpreal alpha)
{
    *pt0 = compAt(_bound_primpoints, prim_id, 0);
    const int pt1 = compAt(_bound_primpoints, prim_id, 1);

    const fpreal3 p0 = vload3(*pt0, _bound_P);
    const fpreal3 p1 = vload3(pt1, _bound_P);
    
    // C0 is the difference in position (p0 - p1), computed during the dual update
    const fpreal3 C0 = vload3(prim_id, _bound_C);
    
    // C is the constraint error
    *C = p0 - p1;
    
    // Store stabilized constraint function, if a hard constraint (Eq. 18)
    // Note stiffness is 3D for each dimension in avbd-2d, here it's 1D
    *stiffness = _bound_stiffness[prim_id] * STIFFNESS_SCALE;
    if (isinf(*stiffness))
    {
        *C -= C0 * alpha;
    }
}

// Energy for joint constraints from AVBD
static void accumulateMaterialForceAndHessian_JointAVBD(
    fpreal3 *force,
    mat3 hessian,
    const int idx,
    const int prim_id,
    global int *_bound_primpoints,
    global int *_bound_primpoints_index,
    const int _bound_primpoints_length,
    global fpreal *_bound_P,
    global fpreal* _bound_stiffness,
    global fpreal* _bound_C,
    global fpreal *_bound_lambda,
    global fpreal *_bound_penalty,
    global fpreal *_bound_fmin,
    global fpreal *_bound_fmax,
    const fpreal alpha)
{
    int pt0;
    fpreal3 C;
    fpreal stiffness;
    computeConstraint_JointAVBD(&pt0, &C, &stiffness,
        prim_id, _bound_primpoints, _bound_primpoints_index, _bound_primpoints_length,
        _bound_P, _bound_C, _bound_stiffness, alpha);
    
    // Joints only use a jacobian (1st derivative)
    // This isn't rotated like in avbd-2d, because @orient isn't supported yet
    mat3 J;
    mat3identity(J);
    if (pt0 != idx)
    {
        mat3scale(J, J, -1);
    }
    
    LOAD_AVBD_ATTRIBS(prim_id);
    accumulateAVBD_Joint(force, hessian, J, C, stiffness, lambda, penalty, fmin, fmax);
}

static void dualUpdate_JointAVBD(
    const int prim_id,
    global int *_bound_primpoints,
    global int *_bound_primpoints_index,
    const int _bound_primpoints_length,
    global fpreal *_bound_P,
    global fpreal* _bound_stiffness,
    global fpreal *_bound_C,
    global fpreal *_bound_lambda,
    global fpreal *_bound_penalty,
    global fpreal *_bound_fmin,
    global fpreal *_bound_fmax,
    global int *_bound_broken,
    global fpreal *_bound_breakthreshold,
    const fpreal alpha,
    const fpreal beta,
    const fpreal PENALTY_MAX)
{
    int pt0;
    fpreal3 C;
    fpreal stiffness;
    computeConstraint_JointAVBD(&pt0, &C, &stiffness,
        prim_id, _bound_primpoints, _bound_primpoints_index, _bound_primpoints_length,
        _bound_P, _bound_C, _bound_stiffness, alpha);
    
    LOAD_AVBD_ATTRIBS(prim_id);
    
    dualUpdateAVBD(_bound_lambda, _bound_penalty, _bound_broken, _bound_breakthreshold, 3,
        prim_id, stiffness, lambda, penalty, C, fmin, fmax, beta, PENALTY_MAX);
}

// Energy for mass-spring constraints, based on their restlength like XPBD
// From https://github.com/AnkaChan/TinyVBD/blob/main/main.cpp#L381
static void accumulateMaterialForceAndHessian_MassSpring(
    fpreal3 *force,
    mat3 hessian,
    const int idx,
    const int prim_id,
    global int *_bound_primpoints,
    global int *_bound_primpoints_index,
    const int _bound_primpoints_length,
    global fpreal *_bound_P,
    global fpreal* _bound_stiffness,
    global fpreal *_bound_restlength,
    global int *_bound_broken,
    global fpreal *_bound_breakthreshold)
{
    // Get the edge's first 2 points, assuming one point is us
    const int pt0 = compAt(_bound_primpoints, prim_id, 0);
    const int pt1 = compAt(_bound_primpoints, prim_id, 1);

    const fpreal3 p0 = vload3(pt0, _bound_P);
    const fpreal3 p1 = vload3(pt1, _bound_P);
    
    const fpreal restlength = _bound_restlength[prim_id];
    const fpreal stiffness = _bound_stiffness[prim_id] * STIFFNESS_SCALE;

    const fpreal3 d = p0 - p1;
    const fpreal dlen2 = dot(d, d);
    if (dlen2 == 0.0f) return;
    
    const fpreal dlen = sqrt(dlen2);
    const fpreal l_ratio = restlength / dlen;
    
    // Mass-spring hessian from TinyVBD
    const fpreal3 x_ident = (fpreal3)(1.0f, 0.0f, 0.0f);
    const fpreal3 y_ident = (fpreal3)(0.0f, 1.0f, 0.0f);
    const fpreal3 z_ident = (fpreal3)(0.0f, 0.0f, 1.0f);
    mat3 ms_hessian = {
        stiffness * (x_ident - l_ratio * (x_ident - (d * d.x) / dlen2)),
        stiffness * (y_ident - l_ratio * (y_ident - (d * d.y) / dlen2)),
        stiffness * (z_ident - l_ratio * (z_ident - (d * d.z) / dlen2))
    };
    
    // SPD approximation from AVBD greatly improves mass-spring
    spdApproximation(ms_hessian);
    
    mat3add(hessian, ms_hessian, hessian);
    
    // Mass-spring force gradient from TinyVBD
    const fpreal stretch = (dlen - restlength) / dlen;
    *force -= stiffness * stretch * d * (pt0 == idx ? 1 : -1);
    
    // Remove the constraint if it exceeds the fracture threshold
    const fpreal breakthreshold = _bound_breakthreshold[prim_id];
    if (breakthreshold >= 0.0f && fabs(stretch) > breakthreshold)
    {
        _bound_broken[prim_id] = 1;
    }
}

// For neo-hookean constraints, turn the 9x9 deformation gradient into a 3x3 hessian
// From https://github.com/AnkaChan/Gaia/blob/main/Simulator/Modules/VBD/VBD_NeoHookean.cpp#L126
static void assembleForceAndHessian_NeoHookean(
    const fpreal9 dE_dF,
    const mat9 d2E_dF,
    const fpreal m1,
    const fpreal m2,
    const fpreal m3,
    fpreal3 *force,
    mat3 hessian)
{
    force->x -= dE_dF[0] * m1 + dE_dF[3] * m2 + dE_dF[6] * m3;
    force->y -= dE_dF[1] * m1 + dE_dF[4] * m2 + dE_dF[7] * m3;
    force->z -= dE_dF[2] * m1 + dE_dF[5] * m2 + dE_dF[8] * m3;

    const fpreal m1sq = m1 * m1;
    const fpreal m2sq = m2 * m2;
    const fpreal m3sq = m3 * m3;
    const fpreal m1m2 = m1 * m2;
    const fpreal m1m3 = m1 * m3;
    const fpreal m2m3 = m2 * m3;

    for (int row = 0; row < 3; ++row)
    {
        const fpreal* row0 = d2E_dF[row];
        const fpreal* row3 = d2E_dF[row + 3];
        const fpreal* row6 = d2E_dF[row + 6];

        hessian[row][0] = row0[0] * m1sq + row0[3] * m1m2 + row0[6] * m1m3 +
                          row3[0] * m1m2 + row3[3] * m2sq + row3[6] * m2m3 +
                          row6[0] * m1m3 + row6[3] * m2m3 + row6[6] * m3sq;
        hessian[row][1] = row0[1] * m1sq + row0[4] * m1m2 + row0[7] * m1m3 +
                          row3[1] * m1m2 + row3[4] * m2sq + row3[7] * m2m3 +
                          row6[1] * m1m3 + row6[4] * m2m3 + row6[7] * m3sq;
        hessian[row][2] = row0[2] * m1sq + row0[5] * m1m2 + row0[8] * m1m3 +
                          row3[2] * m1m2 + row3[5] * m2sq + row3[8] * m2m3 +
                          row6[2] * m1m3 + row6[5] * m2m3 + row6[8] * m3sq;
    }
}

// Energy for neo-hookean constraints, based on each tet's volume deformation
// From https://github.com/AnkaChan/Gaia/blob/main/Simulator/Modules/VBD/VBD_NeoHookean.cpp#L379
static void accumulateMaterialForceAndHessian_NeoHookean(
    fpreal3 *force,
    mat3 hessian,
    const int idx,
    const int prim_id,
    global int *_bound_primpoints,
    global int *_bound_primpoints_index,
    int _bound_primpoints_length,
    global fpreal *_bound_P,
    global fpreal *_bound_pprevious,
    global fpreal *_bound_restlength,
    global fpreal *_bound_restmatrix,
    global fpreal *_bound_stiffness,
    global fpreal *_bound_bendstiffness,
    global fpreal *_bound_dampingratio,
    global fpreal *_bound_benddampingratio,
    const fpreal timeinc,
    const fpreal3 displacement)
{
    // Hydrostatic energy stiffness (volume stiffness)
    const fpreal lmbd = _bound_stiffness[prim_id] * STIFFNESS_SCALE;
    const fpreal lmbd_damping = _bound_dampingratio[prim_id] * DAMPING_SCALE;
    
    // Deviatoric energy stiffness (shear stiffness)
    const fpreal miu = _bound_bendstiffness[prim_id] * STIFFNESS_SCALE;
    const fpreal miu_damping = _bound_benddampingratio[prim_id] * DAMPING_SCALE;
    
    const fpreal a = 1.0f + miu / lmbd;

    const int pt0 = compAt(_bound_primpoints, prim_id, 0);
    const int pt1 = compAt(_bound_primpoints, prim_id, 1);
    const int pt2 = compAt(_bound_primpoints, prim_id, 2);
    const int pt3 = compAt(_bound_primpoints, prim_id, 3);
    
    const fpreal3 p0 = vload3(pt0, _bound_P);
    const fpreal3 p1 = vload3(pt1, _bound_P);
    const fpreal3 p2 = vload3(pt2, _bound_P);
    const fpreal3 p3 = vload3(pt3, _bound_P);

    // Ds = current tet deform
    // Reordered to match Vellum (originally p1 - p0, p2 - p0, p3 - p0)
    mat3 Ds;
    mat3fromcols(p0 - p3, p1 - p3, p2 - p3, Ds);
    
    // Dminv = tet rest deform inverse
    mat3 Dminv;
    mat3load(prim_id, _bound_restmatrix, Dminv);
    
    // F = Ds * Dm^-1 (force for tet)
    mat3 F;
    mat3mul(Ds, Dminv, F);
    
    // This is the wrong order (col major) but only works this way
    const fpreal3 F1 = F[0];
    const fpreal3 F2 = F[1];
    const fpreal3 F3 = F[2];

    const fpreal3 c0 = cross(F2, F3);
    const fpreal3 c1 = cross(F3, F1);
    const fpreal3 c2 = cross(F1, F2);

    const fpreal9 ddetF_dF = {
        c0.x, c1.x, c2.x,
        c0.y, c1.y, c2.y,
        c0.z, c1.z, c2.z
    };

    const fpreal k = det3(F) - a;
    const fpreal restVolume = _bound_restlength[prim_id];
    const fpreal scale_lmbd = restVolume * lmbd;
    const fpreal scale_k = restVolume * k;
    const fpreal scale_miu = restVolume * miu;
    
    // Tets need a 9x9 hessian (second derivative of energy w.r.t the deformation gradient)
    // Vellum only uses a few cross products per tet, so this is much slower
    mat9 d2E_dF_dF;
    
    // Diagonal parts
    d2E_dF_dF[0][0] = scale_lmbd * (ddetF_dF[0] * ddetF_dF[0]) + scale_miu;
    d2E_dF_dF[1][1] = scale_lmbd * (ddetF_dF[1] * ddetF_dF[1]) + scale_miu;
    d2E_dF_dF[2][2] = scale_lmbd * (ddetF_dF[2] * ddetF_dF[2]) + scale_miu;
    d2E_dF_dF[3][3] = scale_lmbd * (ddetF_dF[3] * ddetF_dF[3]) + scale_miu;
    d2E_dF_dF[4][4] = scale_lmbd * (ddetF_dF[4] * ddetF_dF[4]) + scale_miu;
    d2E_dF_dF[5][5] = scale_lmbd * (ddetF_dF[5] * ddetF_dF[5]) + scale_miu;
    d2E_dF_dF[6][6] = scale_lmbd * (ddetF_dF[6] * ddetF_dF[6]) + scale_miu;
    d2E_dF_dF[7][7] = scale_lmbd * (ddetF_dF[7] * ddetF_dF[7]) + scale_miu;
    d2E_dF_dF[8][8] = scale_lmbd * (ddetF_dF[8] * ddetF_dF[8]) + scale_miu;
    
    // Symmetric parts, inlined for speed
    d2E_dF_dF[1][0] = scale_lmbd * (ddetF_dF[0] * ddetF_dF[1]);
    d2E_dF_dF[0][1] = d2E_dF_dF[1][0];
    
    d2E_dF_dF[2][0] = scale_lmbd * (ddetF_dF[0] * ddetF_dF[2]);
    d2E_dF_dF[0][2] = d2E_dF_dF[2][0];
    
    d2E_dF_dF[3][0] = scale_lmbd * (ddetF_dF[0] * ddetF_dF[3]);
    d2E_dF_dF[0][3] = d2E_dF_dF[3][0];
    
    d2E_dF_dF[4][0] = scale_lmbd * (ddetF_dF[0] * ddetF_dF[4]) + scale_k * F3.z;
    d2E_dF_dF[0][4] = d2E_dF_dF[4][0];
    
    d2E_dF_dF[5][0] = scale_lmbd * (ddetF_dF[0] * ddetF_dF[5]) + scale_k * -F2.z;
    d2E_dF_dF[0][5] = d2E_dF_dF[5][0];
    
    d2E_dF_dF[6][0] = scale_lmbd * (ddetF_dF[0] * ddetF_dF[6]);
    d2E_dF_dF[0][6] = d2E_dF_dF[6][0];
    
    d2E_dF_dF[7][0] = scale_lmbd * (ddetF_dF[0] * ddetF_dF[7]) + scale_k * -F3.y;
    d2E_dF_dF[0][7] = d2E_dF_dF[7][0];
    
    d2E_dF_dF[8][0] = scale_lmbd * (ddetF_dF[0] * ddetF_dF[8]) + scale_k * F2.y;
    d2E_dF_dF[0][8] = d2E_dF_dF[8][0];
    
    d2E_dF_dF[2][1] = scale_lmbd * (ddetF_dF[1] * ddetF_dF[2]);
    d2E_dF_dF[1][2] = d2E_dF_dF[2][1];
    
    d2E_dF_dF[3][1] = scale_lmbd * (ddetF_dF[1] * ddetF_dF[3]) + scale_k * -F3.z;
    d2E_dF_dF[1][3] = d2E_dF_dF[3][1];
    
    d2E_dF_dF[4][1] = scale_lmbd * (ddetF_dF[1] * ddetF_dF[4]);
    d2E_dF_dF[1][4] = d2E_dF_dF[4][1];
    
    d2E_dF_dF[5][1] = scale_lmbd * (ddetF_dF[1] * ddetF_dF[5]) + scale_k * F1.z;
    d2E_dF_dF[1][5] = d2E_dF_dF[5][1];
    
    d2E_dF_dF[6][1] = scale_lmbd * (ddetF_dF[1] * ddetF_dF[6]) + scale_k * F3.y;
    d2E_dF_dF[1][6] = d2E_dF_dF[6][1];
    
    d2E_dF_dF[7][1] = scale_lmbd * (ddetF_dF[1] * ddetF_dF[7]);
    d2E_dF_dF[1][7] = d2E_dF_dF[7][1];
    
    d2E_dF_dF[8][1] = scale_lmbd * (ddetF_dF[1] * ddetF_dF[8]) + scale_k * -F1.y;
    d2E_dF_dF[1][8] = d2E_dF_dF[8][1];
    
    d2E_dF_dF[3][2] = scale_lmbd * (ddetF_dF[2] * ddetF_dF[3]) + scale_k * F2.z;
    d2E_dF_dF[2][3] = d2E_dF_dF[3][2];
    
    d2E_dF_dF[4][2] = scale_lmbd * (ddetF_dF[2] * ddetF_dF[4]) + scale_k * -F1.z;
    d2E_dF_dF[2][4] = d2E_dF_dF[4][2];
    
    d2E_dF_dF[5][2] = scale_lmbd * (ddetF_dF[2] * ddetF_dF[5]);
    d2E_dF_dF[2][5] = d2E_dF_dF[5][2];
    
    d2E_dF_dF[6][2] = scale_lmbd * (ddetF_dF[2] * ddetF_dF[6]) + scale_k * -F2.y;
    d2E_dF_dF[2][6] = d2E_dF_dF[6][2];
    
    d2E_dF_dF[7][2] = scale_lmbd * (ddetF_dF[2] * ddetF_dF[7]) + scale_k * F1.y;
    d2E_dF_dF[2][7] = d2E_dF_dF[7][2];
    
    d2E_dF_dF[8][2] = scale_lmbd * (ddetF_dF[2] * ddetF_dF[8]);
    d2E_dF_dF[2][8] = d2E_dF_dF[8][2];
    
    d2E_dF_dF[4][3] = scale_lmbd * (ddetF_dF[3] * ddetF_dF[4]);
    d2E_dF_dF[3][4] = d2E_dF_dF[4][3];
    
    d2E_dF_dF[5][3] = scale_lmbd * (ddetF_dF[3] * ddetF_dF[5]);
    d2E_dF_dF[3][5] = d2E_dF_dF[5][3];
    
    d2E_dF_dF[6][3] = scale_lmbd * (ddetF_dF[3] * ddetF_dF[6]);
    d2E_dF_dF[3][6] = d2E_dF_dF[6][3];
    
    d2E_dF_dF[7][3] = scale_lmbd * (ddetF_dF[3] * ddetF_dF[7]) + scale_k * F3.x;
    d2E_dF_dF[3][7] = d2E_dF_dF[7][3];
    
    d2E_dF_dF[8][3] = scale_lmbd * (ddetF_dF[3] * ddetF_dF[8]) + scale_k * -F2.x;
    d2E_dF_dF[3][8] = d2E_dF_dF[8][3];
    
    d2E_dF_dF[5][4] = scale_lmbd * (ddetF_dF[4] * ddetF_dF[5]);
    d2E_dF_dF[4][5] = d2E_dF_dF[5][4];
    
    d2E_dF_dF[6][4] = scale_lmbd * (ddetF_dF[4] * ddetF_dF[6]) + scale_k * -F3.x;
    d2E_dF_dF[4][6] = d2E_dF_dF[6][4];
    
    d2E_dF_dF[7][4] = scale_lmbd * (ddetF_dF[4] * ddetF_dF[7]);
    d2E_dF_dF[4][7] = d2E_dF_dF[7][4];
    
    d2E_dF_dF[8][4] = scale_lmbd * (ddetF_dF[4] * ddetF_dF[8]) + scale_k * F1.x;
    d2E_dF_dF[4][8] = d2E_dF_dF[8][4];
    
    d2E_dF_dF[6][5] = scale_lmbd * (ddetF_dF[5] * ddetF_dF[6]) + scale_k * F2.x;
    d2E_dF_dF[5][6] = d2E_dF_dF[6][5];
    
    d2E_dF_dF[7][5] = scale_lmbd * (ddetF_dF[5] * ddetF_dF[7]) + scale_k * -F1.x;
    d2E_dF_dF[5][7] = d2E_dF_dF[7][5];
    
    d2E_dF_dF[8][5] = scale_lmbd * (ddetF_dF[5] * ddetF_dF[8]);
    d2E_dF_dF[5][8] = d2E_dF_dF[8][5];
    
    d2E_dF_dF[7][6] = scale_lmbd * (ddetF_dF[6] * ddetF_dF[7]);
    d2E_dF_dF[6][7] = d2E_dF_dF[7][6];
    
    d2E_dF_dF[8][6] = scale_lmbd * (ddetF_dF[6] * ddetF_dF[8]);
    d2E_dF_dF[6][8] = d2E_dF_dF[8][6];
    
    d2E_dF_dF[8][7] = scale_lmbd * (ddetF_dF[7] * ddetF_dF[8]);
    d2E_dF_dF[7][8] = d2E_dF_dF[8][7];

    fpreal9 dE_dF;
    for (int row = 0; row < 3; ++row)
    {
        for (int col = 0; col < 3; ++col)
        {
            // i is likely wrong too (col major), but it only works this way
            const int i = col * 3 + row;
            dE_dF[i] = restVolume * (F[row][col] * miu + ddetF_dF[i] * lmbd * k);
        }
    }

    // Reordered to match Vellum (originally p1 - p0, p2 - p0, p3 - p0)
    // The deformation direction depends on which point we are, but the forces stay the same
    fpreal m1, m2, m3;
    if (pt0 == idx)
    {
        m1 = Dminv[0][0];
        m2 = Dminv[0][1];
        m3 = Dminv[0][2];
    }
    else if (pt1 == idx)
    {
        m1 = Dminv[1][0];
        m2 = Dminv[1][1];
        m3 = Dminv[1][2];
    } 
    else if (pt2 == idx)
    {
        m1 = Dminv[2][0];
        m2 = Dminv[2][1];
        m3 = Dminv[2][2];
    }
    else
    {
        m1 = -Dminv[0][0] - Dminv[1][0] - Dminv[2][0];
        m2 = -Dminv[0][1] - Dminv[1][1] - Dminv[2][1];
        m3 = -Dminv[0][2] - Dminv[1][2] - Dminv[2][2];
    }

    // Store the hessian here for damping
    mat3 d2E_dxi_dxi;
    assembleForceAndHessian_NeoHookean(dE_dF, d2E_dF_dF, m1, m2, m3, force, d2E_dxi_dxi);

#if has_otis
    // Use the hessian approximation from Otis, I can't be bothered rewriting this
    projectToSPD(d2E_dxi_dxi);
#else
    // Use the hessian approximation from AVBD, less stable
    spdApproximation(d2E_dxi_dxi);
#endif

    // Damping doesn't work well, but there's a few definitions for it in GAIA
    // This one is from https://github.com/AnkaChan/Gaia/blob/main/Simulator/Modules/VBD/VBDPhysicsCompute.cu#L2198
    if (lmbd_damping > 0.0f || miu_damping > 0.0f)
    {
        mat3 dampingH;
        mat3scale(dampingH, d2E_dxi_dxi, lmbd_damping);
        fpreal tmp = (m1 * m1 + m2 * m2 + m3 * m3) * miu * restVolume;
        _mat3adddiag(d2E_dxi_dxi, d2E_dxi_dxi, tmp);
        tmp *= miu_damping;
        
        _mat3adddiag(dampingH, dampingH, tmp);
        mat3scale(dampingH, dampingH, 1.0f / timeinc);

        *force -= mat3vecmul(dampingH, displacement);
        mat3add(d2E_dxi_dxi, dampingH, d2E_dxi_dxi);
    }
    
    mat3add(hessian, d2E_dxi_dxi, hessian);
}

// From https://github.com/AnkaChan/Gaia/blob/main/Simulator/Modules/VBD/VBDPhysics.cpp#L2786
// Doesn't work well and tends to dampen gravity, but makes cool patterns in Vellum 2nd order mode
static void accumulateDampingForceAndHessian(
    fpreal3 *force,
    mat3 hessian,
    const fpreal3 velocity,
    const fpreal timeinc,
    const mat3 K,
    const fpreal gamma)
{
    const fpreal3 damping_force = -gamma * mat3vecmul(K, velocity);
    mat3 damping_hessian;
    mat3scale(damping_hessian, K, gamma / timeinc);
    
    *force += damping_force;
    mat3add(hessian, damping_hessian, hessian);
}

// Energy from friction, used for all types of collisions in GAIA
// From https://github.com/AnkaChan/Gaia/blob/main/Simulator/Modules/VBD/VBD_GeneralCompute.h#L10
// Based on https://github.com/ipc-sim/ipc-toolkit/blob/main/src/ipc/friction/smooth_friction_mollifier.cpp
static void accumulateVertexFriction(
    const fpreal mu,
    const fpreal lambda,
    const mat32 T,
    const fpreal2 u,
    const fpreal epsU,
    fpreal3 *force,
    mat3 hessian)
{
    const fpreal uNorm = length(u);
    if (uNorm <= 0.0f) return;
    
    // IPC friction
    const fpreal f1_SF_over_x = uNorm > epsU ? 1.0f / uNorm : (-uNorm / epsU + 2.0f) / epsU;
    const fpreal mu_lambda_eps = mu * lambda * f1_SF_over_x;
    *force -= mu_lambda_eps * _mat32vecmul(T, u);
    
    // Compute T * (f1_SF_over_x * mat2ident()) * transpose(T)
    // This results in some nice cancellations
    for (int row = 0; row < 3; ++row)
    {
        for (int col = 0; col < 3; ++col)
        {
            for (int i = 0; i < 2; ++i)
            {
                hessian[row][col] += T[row][i] * T[col][i] * mu_lambda_eps;
            }
        }
    }
}

// Planar collisions with friction
// From https://github.com/AnkaChan/Gaia/blob/main/Simulator/Modules/VBD/VBD_GeneralCompute.h#L87
// Improved by https://github.com/NVIDIA/warp/blob/main/warp/sim/integrator_vbd.py#L513
static void accumulateBoundaryForceAndHessian(
    fpreal3 *force,
    mat3 hessian,
    const fpreal3 P,
    const fpreal3 displacement,
    const fpreal3 ground_pos,
    const fpreal3 ground_normal,
    const fpreal stiffness,
    const fpreal damping,
    const fpreal friction,
    const fpreal epsU,
    const fpreal timeinc)
{
    const fpreal penetration_depth = -dot(ground_normal, P - ground_pos);
    if (penetration_depth <= 0.0f) return;
    
    // Collisions can be overpowered by stiff constraints, causing penetration
    // This should be improved by hard constraints from AVBD
    const fpreal ground_force_norm = penetration_depth * stiffness;
    *force += ground_normal * ground_force_norm;
    
    mat3 ground_hessian;
    outerprod3(ground_normal, ground_normal, ground_hessian);
    mat3scale(ground_hessian, ground_hessian, stiffness);
    
    // Apply damping
    if (dot(displacement, ground_normal) < 0.0f)
    {
        mat3 damping_hessian;
        mat3scale(damping_hessian, ground_hessian, damping / timeinc);
        *force -= mat3vecmul(damping_hessian, displacement);
        mat3sub(ground_hessian, damping_hessian, ground_hessian);
    }
    
    mat3add(hessian, ground_hessian, hessian);
    
    // Apply friction
    if (friction <= 0.0f) return;
    mat32 T;
    buildOrthonormalBasis(ground_normal, T);
    const fpreal2 u = _mat32Tvecmul(T, displacement);
    accumulateVertexFriction(friction, ground_force_norm, T, u, epsU * timeinc, force, hessian);
}

// Worksets are computed in graph_color for points, as required for Vertex Block Descent
// See pbd_constraints.cl for another example, note it runs on prims instead
// For Vellum compatibility, you need two separate worksets (one for points, one for prims)

// Coloring is based on ConstraintGeometry, since ConstraintGeometry has many more connections
// This ensures coloring respects all connections for the best possible stability
kernel void solveConstraints(
    int color_offset,
    int color_length,
    const fpreal timeinc,
    int _bound_P_length,
    global fpreal * restrict _bound_P,
    int _bound_coloredidx_length,
    global int * restrict _bound_coloredidx,
    int _bound_inertia_length,
    global fpreal * restrict _bound_inertia,
    int _bound_mass_length,
    global fpreal * restrict _bound_mass,
    int _bound_stopped_length,
    global int * restrict _bound_stopped,
    int _bound_pointprims_length,
    global int * restrict _bound_pointprims_index,
    global int * restrict _bound_pointprims,
    int _bound_restlength_length,
    global fpreal * restrict _bound_restlength,
#ifdef HAS_restmatrix
    int _bound_restmatrix_length,
    global fpreal * restrict _bound_restmatrix,
#endif
    int _bound_stiffness_length,
    global fpreal * restrict _bound_stiffness,
#ifdef HAS_bendstiffness
    int _bound_bendstiffness_length,
    global fpreal * restrict _bound_bendstiffness,
#endif
#ifdef HAS_dampingratio
    int _bound_dampingratio_length,
    global fpreal * restrict _bound_dampingratio,
#endif
#ifdef HAS_benddampingratio
    int _bound_benddampingratio_length,
    global fpreal * restrict _bound_benddampingratio,
#endif
    int _bound_primpoints_length,
    global int * restrict _bound_primpoints_index,
    global int * restrict _bound_primpoints,
#ifdef HAS_omega
    int _bound_omega_length,
    global fpreal * restrict _bound_omega,
#endif
    const fpreal accel_rho,
#ifdef HAS_iteration
    int iteration,
#endif
#ifdef HAS_plastiter
    int _bound_plastiter_length,
    global fpreal * restrict _bound_plastiter,
#endif
    const int solve_method,
    const fpreal min_force,
    const fpreal min_hessian,
    const fpreal convergence,
    int _bound_type_length,
    global int * restrict _bound_type,
    int _bound_pprevious_length,
    global fpreal * restrict _bound_pprevious,
    const fpreal damping,
    const short use_ground,
    const fpreal3 ground_pos,
    const fpreal ground_stiffness,
    const fpreal ground_friction,
    const fpreal ground_epsilon,
    const fpreal3 ground_normal,
    const fpreal ground_damping,
    int _bound_lambda_length,
    global fpreal * restrict _bound_lambda,
    int _bound_penalty_length,
    global fpreal * restrict _bound_penalty,
    int _bound_fmin_length,
    global fpreal * restrict _bound_fmin,
    int _bound_fmax_length,
    global fpreal * restrict _bound_fmax,
    int _bound_broken_length,
    global int * restrict _bound_broken,
    int _bound_breakthreshold_length,
    global fpreal * restrict _bound_breakthreshold,
    const fpreal alpha,
    const fpreal beta,
    const fpreal PENALTY_MAX,
    int _bound_C_length,
    global fpreal * restrict _bound_C,
    int _bound_pointsupdated_length,
    global int * restrict _bound_pointsupdated)
{
    // Like Vellum, everything here is based on timeinc
    if (timeinc == 0.0f) return;
    
    int idx = get_global_id(0);
    if (idx >= color_length) return;
    idx += color_offset;
    
    const fpreal mass = _bound_mass[idx];
    const int stopped = _bound_stopped[idx];
    if (mass <= 0.0f || stopped) return; // Skip pinned points
    
    // @coloredidx maps from Geometry to ConstraintGeometry pointprims
    int coloredidx = _bound_coloredidx[idx];
    if (coloredidx < 0) return;
    
    fpreal3 P = vload3(idx, _bound_P);
    const fpreal3 pprevious = vload3(idx, _bound_pprevious);
    const fpreal3 inertia = vload3(idx, _bound_inertia);

#ifdef HAS_plastiter
    const fpreal3 P_before_solve = P;
#endif
    
    // Everything gets added to the force and hessian below
    // Then the position gets updated: P += force * invert(hessian)
    fpreal3 force = (fpreal3)(0.0f);
    mat3 hessian;
    mat3zero(hessian);
    
    // Include energy from inertia (this includes gravity) and mass
    accumulateInertiaForceAndHessian(&force, hessian, mass, P, inertia, timeinc);
    
    // Damping only affects the hessian for material forces in GAIA
    // https://github.com/AnkaChan/Gaia/blob/main/Simulator/Modules/VBD/VBDPhysics.cpp#L2347-L2351
    mat3 tmp_hessian;
    if (damping > 0.0f)
    {
        mat3copy(hessian, tmp_hessian);
    }
    
    // Only use dual solving when AVBD constraints are connected
    int dual_solve = 0;
    
    // Accumulate energy for each constraint connected to the current point
    // I tried hard to get this to run in parallel, but the performance was always worse :(
    const int num_constraints = entriesAt(_bound_pointprims, coloredidx);
    for (int constraint_id = 0; constraint_id < num_constraints; ++constraint_id)
    {
        const int prim_id = compAt(_bound_pointprims, coloredidx, constraint_id);
        const int constraint_type = _bound_type[prim_id];
        
        switch (constraint_type)
        {
            case VBD_MASS_SPRING:
            {
                accumulateMaterialForceAndHessian_MassSpring(&force, hessian, idx, prim_id,
                    _bound_primpoints, _bound_primpoints_index, _bound_primpoints_length,
                    _bound_P, _bound_stiffness, _bound_restlength, _bound_broken, _bound_breakthreshold);
                break;
            }
            case AVBD_SPRING:
            {
                accumulateMaterialForceAndHessian_SpringAVBD(&force, hessian, idx, prim_id,
                    _bound_primpoints, _bound_primpoints_index, _bound_primpoints_length,
                    _bound_P, _bound_stiffness, _bound_restlength, _bound_lambda, _bound_penalty,
                    _bound_fmin, _bound_fmax);
                // Dual solving is allowed once we've updated all points for this prim
                dual_solve |= (atomic_add(&_bound_pointsupdated[prim_id], 1) + 1) == num_constraints;
                break;
            }
            case AVBD_JOINT:
            {
                accumulateMaterialForceAndHessian_JointAVBD(&force, hessian, idx, prim_id,
                    _bound_primpoints, _bound_primpoints_index, _bound_primpoints_length,
                    _bound_P, _bound_stiffness, _bound_C, _bound_lambda, _bound_penalty, _bound_fmin,
                    _bound_fmax, alpha);
                // Dual solving is allowed once we've updated all points for this prim
                dual_solve |= (atomic_add(&_bound_pointsupdated[prim_id], 1) + 1) == num_constraints;
                break;
            }
#if defined(HAS_restmatrix) && defined(HAS_bendstiffness) && defined(HAS_dampingratio) && defined(HAS_benddampingratio)
            case VBD_NEO_HOOKEAN:
            {
                accumulateMaterialForceAndHessian_NeoHookean(&force, hessian, idx, prim_id,
                    _bound_primpoints, _bound_primpoints_index, _bound_primpoints_length,
                    _bound_P, _bound_pprevious, _bound_restlength, _bound_restmatrix,
                    _bound_stiffness, _bound_bendstiffness, _bound_dampingratio,
                    _bound_benddampingratio, timeinc, P - pprevious);
                break;
            }
#endif
        }
    }
    
    // Apply damping, doesn't work well but makes cool patterns
    if (damping > 0.0f)
    {
        mat3 K;
        mat3sub(hessian, tmp_hessian, K);
        accumulateDampingForceAndHessian(&force, hessian, (P - pprevious) / timeinc,
            timeinc, K, damping * timeinc * DAMPING_SCALE);
    }
    
    if (use_ground && ground_stiffness > 0.0f)
    {
        accumulateBoundaryForceAndHessian(
            &force, hessian, P, P - pprevious, ground_pos, normalize(ground_normal),
            ground_stiffness, ground_damping * DAMPING_SCALE, ground_friction, ground_epsilon, timeinc);
    }
    
    // The core of VBD: P += force * invert(hessian)
    // Sadly invert(hessian) is mega unstable, so we bandaid it below
    if (dot(force, force) > (min_force * min_force))
    {
        if (solve_method == 0)
        {
            fpreal3 descent_direction;
            const int success = solveDirect(force, hessian, &descent_direction, min_hessian);
            if (success)
            {
                P += descent_direction * convergence;
                vstore3(P, idx, _bound_P);
            }
        }
        else if (fabs(det3(hessian)) > min_hessian)
        {
            P += solveLDLT(force, hessian) * convergence; // Requires the hessian to be SPD
            vstore3(P, idx, _bound_P);
        }
    }

#if defined(HAS_omega) && defined(HAS_plastiter) && defined(HAS_iteration)
    // Accelerated convergence, tends to explode so disabled by default
    const fpreal omega = _getAcceleratorOmega(iteration + 1, accel_rho, _bound_omega[idx]);
    _bound_omega[idx] = omega;

    const fpreal3 plast = vload3(idx, _bound_plastiter);
    P = plast + (P - plast) * omega;
    vstore3(P, idx, _bound_P);

    vstore3(P_before_solve, idx, _bound_plastiter);
#endif

    if (!dual_solve) return;

    // Dual solve for AVBD, 2x faster to run it here than in a separate prim kernel
    for (int constraint_id = 0; constraint_id < num_constraints; ++constraint_id)
    {
        const int prim_id = compAt(_bound_pointprims, coloredidx, constraint_id);
        
        // Dual solve is only valid once all points of the constraint are updated
        const int points_updated = _bound_pointsupdated[prim_id];
        if (points_updated != num_constraints) continue;
        
        const int constraint_type = _bound_type[prim_id];
        switch (constraint_type)
        {
            case AVBD_SPRING:
            {
                dualUpdate_SpringAVBD(prim_id, _bound_primpoints, _bound_primpoints_index, _bound_primpoints_length,
                    _bound_P, _bound_stiffness, _bound_restlength, _bound_lambda, _bound_penalty,
                    _bound_fmin, _bound_fmax, _bound_broken, _bound_breakthreshold, beta, PENALTY_MAX);
                break;
            }
            case AVBD_JOINT:
            {
                dualUpdate_JointAVBD(prim_id, _bound_primpoints, _bound_primpoints_index, _bound_primpoints_length,
                    _bound_P, _bound_stiffness, _bound_C, _bound_lambda, _bound_penalty,
                    _bound_fmin, _bound_fmax, _bound_broken, _bound_breakthreshold, alpha, beta, PENALTY_MAX);
                break;
            }
        }
    }
}