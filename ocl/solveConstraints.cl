#include <matrix.h>

// Constraint hash IDs, generated by constraintHash() in VEX
#define MASS_SPRING 10827462
#define STVK 1548373415
#define NEO_HOOKEAN 1206786922

// Faster but memory unsafe
#define entriesAt_unsafe(_arr_, _idx_) (_arr_##_index[_idx_+1] - _arr_##_index[_idx_])
#define compAt_unsafe(_arr_, _idx_, _compidx_) _arr_[_arr_##_index[_idx_] + _compidx_]

#define entriesAt(_arr_, _idx_) ((_idx_ >= 0 && _idx_ < _arr_##_length) ? (_arr_##_index[_idx_+1] - _arr_##_index[_idx_]) : 0)
#define compAt(_arr_, _idx_, _compidx_) ((_idx_ >= 0 && _idx_ < _arr_##_length && _compidx_ >= 0 && _compidx_ < entriesAt_unsafe(_arr_, _idx_)) ? _arr_[_arr_##_index[_idx_] + _compidx_] : 0)

static fpreal3 mat32vecmul(const mat32 a, const fpreal2 b)
{
    return (fpreal3)(dot(a[0], b), dot(a[1], b), dot(a[2], b));
}

static fpreal2 mat32Tvecmul(const mat32 a, const fpreal3 b)
{
    return (fpreal2)(a[0][0] * b.x + a[1][0] * b.y + a[2][0] * b.z,
                     a[0][1] * b.x + a[1][1] * b.y + a[2][1] * b.z);
}

// From https://graphics.pixar.com/library/OrthonormalB/paper.pdf
void buildOrthonormalBasis(const fpreal3 n, mat32 out)
{
    const fpreal sign = copysign(1.0f, n.z);
    const fpreal a = -1.0f / (sign + n.z);
    const fpreal b = n.x * n.y * a;
    out[0][0] = 1.0f + sign * n.x * n.x * a;
    out[1][0] = sign * b;
    out[2][0] = -sign * n.x;
    out[0][1] = b;
    out[1][1] = sign + n.y * n.y * a;
    out[2][1] = -n.y;
}

// force * invert(hessian) using LDLT decomposition
// From https://github.com/savant117/avbd-demo2d/blob/main/source/maths.h#L323
static inline fpreal3 solveLDLT(
    const fpreal3 force,
    const mat3 hessian)
{
    // Compute LDL^T decomposition
    const fpreal D1 = hessian[0][0];
    const fpreal L21 = hessian[1][0] / hessian[0][0];
    const fpreal L31 = hessian[2][0] / hessian[0][0];
    const fpreal D2 = hessian[1][1] - L21 * L21 * D1;
    const fpreal L32 = (hessian[2][1] - L21 * L31 * D1) / D2;
    const fpreal D3 = hessian[2][2] - (L31 * L31 * D1 + L32 * L32 * D2);

    // Forward substitution: Solve Ly = f
    const fpreal y1 = force.x;
    const fpreal y2 = force.y - L21 * y1;
    const fpreal y3 = force.z - L31 * y1 - L32 * y2;

    // Diagonal solve: Solve Dz = y
    const fpreal z1 = y1 / D1;
    const fpreal z2 = y2 / D2;
    const fpreal z3 = y3 / D3;

    // Backward substitution: Solve L^T x = z
    fpreal3 x;
    x[2] = z3;
    x[1] = z2 - L32 * x[2];
    x[0] = z1 - L21 * x[1] - L31 * x[2];

    return x;
}

// out = force * invert(hessian) with a check similar to absf(det3(hessian)) > epsilon
// From https://github.com/AnkaChan/CuMatrix/blob/main/CuMatrix/MatrixOps/CuMatrix.h#L235
static inline int solveDirect(
    const fpreal3 force,
    const mat3 hessian,
    fpreal3 *out,
    const fpreal epsilon)
{
    const fpreal s0 = hessian[0][0], s3 = hessian[1][0], s6 = hessian[2][0];
    const fpreal s1 = hessian[0][1], s4 = hessian[1][1], s7 = hessian[2][1];
    const fpreal s2 = hessian[0][2], s5 = hessian[1][2], s8 = hessian[2][2];
    
    const fpreal i0 = s8 * s4 - s5 * s7;
    const fpreal i1 = -(s8 * s3 - s5 * s6);
    const fpreal i2 = s7 * s3 - s4 * s6;
    
    const fpreal det = s0 * i0 + s1 * i1 + s2 * i2;
    if (fabs(det) < epsilon * (fabs(s0 * i0) + fabs(s1 * i1) + fabs(s2 * i2)))
    {
        (*out) = force;
        return 0;
    }
    
    (*out).x = (i0 * force.x + i1 * force.y + i2 * force.z) / det;
    (*out).y = (-(s8 * s1 - s2 * s7) * force.x +  (s8 * s0 - s2 * s6) * force.y + -(s7 * s0 - s1 * s6) * force.z) / det;
    (*out).z = ( (s5 * s1 - s2 * s4) * force.x + -(s5 * s0 - s2 * s3) * force.y +  (s4 * s0 - s1 * s3) * force.z) / det;
    return 1;
}

// Used for accelerated convergence, tends to explode. Probably will remove later
// From https://github.com/AnkaChan/TinyVBD/blob/main/main.cpp#L193
static inline fpreal getAcceleratorOmega(
    const int order,
    const fpreal pho,
    const fpreal prev_omega)
{
    switch (order)
    {
        case 1:
            return 1.0f;
        case 2:
            return 2.0f / (2.0f - (pho * pho));
        default:
            return 4.0f / (4.0f - (pho * pho) * prev_omega);
    }
}

// Include influence from inertia
// From https://github.com/AnkaChan/Gaia/blob/main/Simulator/Modules/VBD/VBD_BaseMaterial.h#L359
static inline void accumulateInertiaForceAndHessian(
    fpreal3 *force,
    mat3 hessian,
    const fpreal mass,
    const fpreal3 P,
    const fpreal3 inertia,
    const fpreal dt_sqr_reciprocal)
{
    const fpreal md = mass * dt_sqr_reciprocal;
    (*force) += (inertia - P) * md;
    hessian[0] += (fpreal3)(md, 0.0f, 0.0f);
    hessian[1] += (fpreal3)(0.0f, md, 0.0f);
    hessian[2] += (fpreal3)(0.0f, 0.0f, md);
}

// Symmetric positive definite approximation of the hessian, greatly improves stability
static inline void spdApproximation(mat3 h)
{
    // Column norm in the diagonal
    const fpreal x0 = h[0][0], y0 = h[1][0], z0 = h[2][0];
    const fpreal x1 = h[0][1], y1 = h[1][1], z1 = h[2][1];
    const fpreal x2 = h[0][2], y2 = h[1][2], z2 = h[2][2];
    h[0][0] = sqrt(x0*x0 + y0*y0 + z0*z0);
    h[1][1] = sqrt(x1*x1 + y1*y1 + z1*z1);
    h[2][2] = sqrt(x2*x2 + y2*y2 + z2*z2);

    // Wipe everything else
    h[0][1] = 0.0f; h[0][2] = 0.0f;
    h[1][0] = 0.0f; h[1][2] = 0.0f;
    h[2][0] = 0.0f; h[2][1] = 0.0f;
}

// Include influence from spring constraints, for mass-spring energy
static inline void accumulateMaterialForceAndHessian_MassSpring(
    fpreal3 *force,
    mat3 hessian,
    const int idx,
    const int prim_id,
    global int *_bound_primpoints,
    global int *_bound_primpoints_index,
    const int _bound_primpoints_length,
    global fpreal *_bound_P,
    global fpreal* _bound_stiffness,
    global fpreal *_bound_restlength,
    const int improve_stability)
{
    // Get the edge's first 2 points, assuming one point is us
    const int pt0 = compAt(_bound_primpoints, prim_id, 0);
    const int pt1 = compAt(_bound_primpoints, prim_id, 1);
    const fpreal3 p0 = vload3(pt0, _bound_P);
    const fpreal3 p1 = vload3(pt1, _bound_P);
    
    const fpreal3 diff = p0 - p1;
    const fpreal length_current = length(diff);
    const fpreal length_target = _bound_restlength[prim_id];
    const fpreal length_ratio = length_target / length_current;
    const fpreal length2 = length_current * length_current;
    
    // VBD is about 10x less stiff than Vellum
    const fpreal stiffness = _bound_stiffness[prim_id] * 10.0f;
    
    // Hessian for the mass-spring energy definition, inlined for speed
    // From https://github.com/AnkaChan/TinyVBD/blob/main/main.cpp#L381
    mat3 ms_hessian;
    const fpreal3 x_ident = (fpreal3)(1.0f, 0.0f, 0.0f);
    const fpreal3 y_ident = (fpreal3)(0.0f, 1.0f, 0.0f);
    const fpreal3 z_ident = (fpreal3)(0.0f, 0.0f, 1.0f);
    ms_hessian[0] = stiffness * (x_ident - length_ratio * (x_ident - (diff * diff.x) / length2));
    ms_hessian[1] = stiffness * (y_ident - length_ratio * (y_ident - (diff * diff.y) / length2));
    ms_hessian[2] = stiffness * (z_ident - length_ratio * (z_ident - (diff * diff.z) / length2));
    
    // Diagonal SPD approximation from AVBD greatly improves stability
    if (improve_stability) spdApproximation(ms_hessian);
    
    mat3add(hessian, ms_hessian, hessian);
    
    // Force for the mass-spring energy definition
    // From https://github.com/AnkaChan/TinyVBD/blob/main/main.cpp#L384-L391
    (*force) += (stiffness * (length_target - length_current) / length_current) * diff * (pt0 == idx ? 1 : -1);
}

// From https://github.com/AnkaChan/Gaia/blob/main/Simulator/Modules/VBD/VBDPhysics.cpp#L2786
// Doesn't always work well, but makes cool looking patterns
static inline void accumulateDampingForceAndHessian(
    fpreal3 *force,
    mat3 hessian,
    const fpreal3 velocity,
    const fpreal timeinc,
    const mat3 K,
    const fpreal gamma)
{
    const fpreal3 damping_force = -gamma * mat3vecmul(K, velocity);
    mat3 damping_hessian;
    mat3scale(damping_hessian, K, gamma / timeinc);
    
    (*force) += damping_force;
    mat3add(hessian, damping_hessian, hessian);
}

// From https://github.com/AnkaChan/Gaia/blob/main/Simulator/Modules/VBD/VBD_GeneralCompute.h#L10
// Based on https://github.com/ipc-sim/ipc-toolkit/blob/main/src/ipc/friction/smooth_friction_mollifier.cpp
static inline void accumulateVertexFriction(
    const fpreal mu,
    const fpreal lambda,
    const mat32 T,
    const fpreal2 u,
    const fpreal epsU,
    fpreal3 *force,
    mat3 hessian)
{
    const fpreal uNorm = length(u);
    if (uNorm <= 0.0f) return;
    
    // IPC friction
    const fpreal f1_SF_over_x = uNorm > epsU ? 1.0f / uNorm : (-uNorm / epsU + 2.0f) / epsU;
    const fpreal mu_lambda_eps = mu * lambda * f1_SF_over_x;
    (*force) -= mu_lambda_eps * mat32vecmul(T, u);
    
    // Compute T * (f1_SF_over_x * mat2ident()) * transpose(T)
    // This results in some nice cancellations
    for (int row = 0; row < 3; ++row)
    {
        for (int col = 0; col < 3; ++col)
        {
            for (int i = 0; i < 2; ++i)
            {
                hessian[row][col] += T[row][i] * T[col][i] * mu_lambda_eps;
            }
        }
    }
}

// From https://github.com/AnkaChan/Gaia/blob/main/Simulator/Modules/VBD/VBD_GeneralCompute.h#L87
// Improved by https://github.com/NVIDIA/warp/blob/main/warp/sim/integrator_vbd.py#L513
static inline void accumulateBoundaryForceAndHessian(
    fpreal3 *force,
    mat3 hessian,
    const fpreal3 P,
    const fpreal3 pprevious,
    const fpreal3 ground_pos,
    const fpreal3 ground_normal,
    const fpreal stiffness,
    const fpreal damping,
    const fpreal friction,
    const fpreal epsU,
    const fpreal timeinc)
{
    const fpreal penetration_depth = -dot(ground_normal, P - ground_pos);
    if (penetration_depth <= 0.0f) return;
    
    const fpreal3 diff = P - pprevious;
    const fpreal ground_force_norm = penetration_depth * stiffness;
    (*force) += ground_normal * ground_force_norm;
    
    mat3 ground_hessian;
    outerprod3(ground_normal, ground_normal, ground_hessian);
    mat3scale(ground_hessian, ground_hessian, stiffness);
    
    // Apply damping
    if (dot(diff, ground_normal) < 0.0f)
    {
        mat3 damping_hessian;
        mat3scale(damping_hessian, ground_hessian, damping / timeinc);
        (*force) -= mat3vecmul(damping_hessian, diff);
        mat3add(ground_hessian, damping_hessian, ground_hessian);
    }
    
    mat3add(hessian, ground_hessian, hessian);
    
    // Apply friction
    if (friction <= 0.0f) return;
    mat32 T;
    buildOrthonormalBasis(ground_normal, T);
    const fpreal2 u = mat32Tvecmul(T, diff);
    accumulateVertexFriction(friction, ground_force_norm, T, u, epsU * timeinc, force, hessian);
}

// I stole the workgroup span code from Vellum (pbd_constraints.cl)
// It ensures stuff runs properly regardless how the workgroups are split
// Check the "Use Single Workgroup" setting in the Options tab to see what it does
kernel void solveConstraints(
#ifdef SINGLE_WORKGROUP
#ifdef SINGLE_WORKGROUP_SPANS
    int startcolor,
#endif
    int ncolors,
    global const int *color_offsets,
    global const int *color_lengths,
#else
    int color_offset,
    int color_length,
#endif
    const fpreal timeinc,
    int _bound_P_length,
    global fpreal * restrict _bound_P,
    int _bound_inertia_length,
    global fpreal * restrict _bound_inertia,
    int _bound_mass_length,
    global fpreal * restrict _bound_mass,
    int _bound_pointprims_length,
    global int * restrict _bound_pointprims_index,
    global int * restrict _bound_pointprims,
    int _bound_restlength_length,
    global fpreal * restrict _bound_restlength,
    int _bound_stiffness_length,
    global fpreal * restrict _bound_stiffness,
    int _bound_primpoints_length,
    global int * restrict _bound_primpoints_index,
    global int * restrict _bound_primpoints,
    int _bound_omega_length,
    global fpreal * restrict _bound_omega,
    const fpreal accel_rho,
    int iteration,
    const int use_accel,
    int _bound_plastiter_length,
    global fpreal * restrict _bound_plastiter,
    const int solve_method,
    const fpreal min_force,
    const fpreal min_hessian,
    const fpreal convergence,
    int _bound_type_length,
    global int * restrict _bound_type,
    int _bound_pprevious_length,
    global fpreal * restrict _bound_pprevious,
    const fpreal damping,
    const int improve_stability,
    const int use_bounds,
    const fpreal3 ground_pos,
    const fpreal ground_stiffness,
    const fpreal ground_friction,
    const fpreal friction_epsilon,
    const fpreal3 ground_normal,
    const fpreal ground_damping
)
{
    // Like Vellum, everything here is based on timeinc
    if (timeinc == 0.0f) return;
#ifdef SINGLE_WORKGROUP
#define SKIPWORKITEM continue
#ifdef SINGLE_WORKGROUP_SPANS
   for (int i = startcolor; i < startcolor + ncolors; ++i)
   {
#else
   for (int i = 0; i < ncolors; ++i)
   {
#endif
        int color_length = color_lengths[i];
        int color_offset = color_offsets[i];
        if (i > 0) barrier(CLK_GLOBAL_MEM_FENCE);
#ifdef SINGLE_WORKGROUP_ALWAYS
    color_offset -= get_global_size(0);
    color_length += get_global_size(0);
    while (1)
    {
        color_offset += get_global_size(0);
        color_length -= get_global_size(0);
        if (color_length <= 0) break;
#endif
#else
#define SKIPWORKITEM return
    {
#endif
    int idx = get_global_id(0);
    if (idx >= color_length) SKIPWORKITEM;
    idx += color_offset;
    
    const fpreal mass = _bound_mass[idx];
    if (mass <= 0.0f) SKIPWORKITEM; // Skip pinned points
    
    fpreal3 P = vload3(idx, _bound_P);
    fpreal3 pprevious = vload3(idx, _bound_pprevious);
    const fpreal3 P_before_solve = P;
    const fpreal3 inertia = vload3(idx, _bound_inertia);
    const fpreal dt_sqr_reciprocal = 1.0f / (timeinc * timeinc);
    
    fpreal3 force = (fpreal3)(0.0f);
    mat3 hessian;
    mat3zero(hessian);
    
    // Include influence from inertia
    accumulateInertiaForceAndHessian(&force, hessian, mass, P, inertia, dt_sqr_reciprocal);
    
    // Damping only affects the hessian for material forces in GAIA
    // https://github.com/AnkaChan/Gaia/blob/main/Simulator/Modules/VBD/VBDPhysics.cpp#L2347-L2351
    mat3 tmp_hessian;
    if (damping > 0.0f)
    {
        mat3copy(hessian, tmp_hessian);
    }
    
    // Solve each constraint connected to the current point
    const int num_constraints = entriesAt(_bound_pointprims, idx);
    for (int constraint_id = 0; constraint_id < num_constraints; ++constraint_id)
    {
        const int prim_id = compAt(_bound_pointprims, idx, constraint_id);
        const int constraint_type = _bound_type[prim_id];
        
        switch (constraint_type)
        {
            case MASS_SPRING:
            default:
            {
                accumulateMaterialForceAndHessian_MassSpring(&force, hessian, idx, prim_id,
                    _bound_primpoints, _bound_primpoints_index, _bound_primpoints_length,
                    _bound_P, _bound_stiffness, _bound_restlength, improve_stability);
                break;
            }
        }
    }
    
    // Include influence from damping, doesn't work well but makes cool patterns
    if (damping > 0.0f)
    {
        mat3 K;
        mat3sub(hessian, tmp_hessian, K);
        accumulateDampingForceAndHessian(&force, hessian, (P - pprevious) / timeinc, timeinc, K, damping * timeinc);
    }
    
    if (use_bounds && ground_stiffness > 0.0f)
    {
        accumulateBoundaryForceAndHessian(
            &force, hessian, P, pprevious, ground_pos, normalize(ground_normal),
            ground_stiffness, ground_damping, ground_friction, friction_epsilon, timeinc);
    }
    
    // The core of VBD is P += force * invert(hessian)
    // Sadly invert(hessian) is mega unstable, so we bandaid it below
    if (dot(force, force) > (min_force * min_force))
    {
        if (solve_method == 0)
        {
            fpreal3 descent_direction;
            const int success = solveDirect(force, hessian, &descent_direction, min_hessian);
            if (success)
            {
                P += descent_direction * convergence;
                vstore3(P, idx, _bound_P);
            }
        }
        else if (fabs(det3(hessian)) > min_hessian)
        {
            P += solveLDLT(force, hessian) * convergence;
            vstore3(P, idx, _bound_P);
        }
    }
    
    // Accelerated convergence tends to explode, so it's disabled by default
    if (use_accel) 
    {
        const fpreal omega = getAcceleratorOmega(iteration + 1, accel_rho, _bound_omega[idx]);
        _bound_omega[idx] = omega;

        const fpreal3 plast = vload3(idx, _bound_plastiter);
        P = plast + (P - plast) * omega;
        vstore3(P, idx, _bound_P);

        vstore3(P_before_solve, idx, _bound_plastiter);
    }
#ifdef SINGLE_WORKGROUP
#ifdef SINGLE_WORKGROUP_ALWAYS
    }
#endif
#endif
    }
}