// Constraint hash IDs, generated by constraintHash() in VEX
// Shared with solveConstraints.cl
#define AVBD_SPRING -1715226869
#define AVBD_JOINT -1456250084

// Faster but memory unsafe
#define entriesAt_unsafe(_arr_, _idx_) (_arr_##_index[_idx_+1] - _arr_##_index[_idx_])
#define compAt_unsafe(_arr_, _idx_, _compidx_) _arr_[_arr_##_index[_idx_] + _compidx_]

#define entriesAt(_arr_, _idx_) ((_idx_ >= 0 && _idx_ < _arr_##_length) ? (_arr_##_index[_idx_+1] - _arr_##_index[_idx_]) : 0)
#define compAt(_arr_, _idx_, _compidx_) ((_idx_ >= 0 && _idx_ < _arr_##_length && _compidx_ >= 0 && _compidx_ < entriesAt_unsafe(_arr_, _idx_)) ? _arr_[_arr_##_index[_idx_] + _compidx_] : 0)

// Rough approximation to match Vellum
// Shared with solveConstraints.cl
const fpreal STIFFNESS_SCALE = 10.0f;

// From https://github.com/savant117/avbd-demo2d/blob/main/source/joint.cpp#L27
static void initialize_JointAVBD(
    const int prim_id,
    global int *_bound_primpoints,
    global int *_bound_primpoints_index,
    const int _bound_primpoints_length,
    global fpreal *_bound_P,
    const int _bound_P_length,
    global fpreal *_bound_C,
    const int _bound_C_length)
{
    const int pt0 = compAt(_bound_primpoints, prim_id, 0);
    const int pt1 = compAt(_bound_primpoints, prim_id, 1);

    const fpreal3 p0 = vload3(pt0, _bound_P);
    const fpreal3 p1 = vload3(pt1, _bound_P);
    
    // C is the difference in position between each connected point
    vstore3(p0 - p1, prim_id, _bound_C);
}

// Dual update from AVBD
// From https://github.com/savant117/avbd-demo2d/blob/main/source/solver.cpp#L105
kernel void forwardStepDual( 
    fpreal alpha,
    fpreal gamma,
    fpreal PENALTY_MIN,
    fpreal PENALTY_MAX,
    int _bound_P_length,
    global fpreal * restrict _bound_P,
    int _bound_primpoints_length,
    global int * restrict _bound_primpoints_index,
    global int * restrict _bound_primpoints,
    int _bound_C_length,
    global fpreal * restrict _bound_C,
    int _bound_lambda_length,
    global fpreal * restrict _bound_lambda,
    int _bound_penalty_length,
    global fpreal * restrict _bound_penalty,
    int _bound_stiffness_length,
    global fpreal * restrict _bound_stiffness,
    int _bound_type_hash_length,
    global int * restrict _bound_type_hash,
    int _bound_pointsupdated_length,
    global int * restrict _bound_pointsupdated
)
{
    const int idx = get_global_id(0);
    if (idx >= _bound_C_length) return;

    // Some constraints use initialization in the dual step
    const int type = _bound_type_hash[idx];
    switch (type)
    {
        case AVBD_SPRING:
        {
            // No initialization needed
            break;
        }
        case AVBD_JOINT:
        {
            initialize_JointAVBD(idx, _bound_primpoints, _bound_primpoints_index, _bound_primpoints_length,
                _bound_P, _bound_P_length, _bound_C, _bound_C_length);
            break;
        }
        default:
        {
            // Ignore non AVBD constraints
            return;
        }
    }
    
    // Warmstart the dual variables and penalty parameters (Eq. 19)
    const fpreal3 lambda = vload3(idx, _bound_lambda);
    vstore3(lambda * alpha * gamma, idx, _bound_lambda);
    
    // Penalty is safely clamped to a minimum and maximum value
    fpreal3 penalty = vload3(idx, _bound_penalty);
    penalty = clamp(penalty * gamma, PENALTY_MIN, PENALTY_MAX);
    
    // If it's not a hard constraint, we don't let the penalty exceed the material stiffness
    const fpreal stiffness = _bound_stiffness[idx];
    vstore3(min(penalty, (fpreal3)(stiffness * STIFFNESS_SCALE)), idx, _bound_penalty);
    
    // Dual updating is normally 2x slower when run separately to solveConstraints
    // Luckily it can be merged into solveConstraints, as long as it happens after the last point update
    _bound_pointsupdated[idx] = 0;
}