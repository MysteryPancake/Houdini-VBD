// Constraint hash IDs, generated by constraintHash() in VEX
// Shared with solveConstraints.cl
#define AVBD_SPRING -1715226869
#define AVBD_JOINT -1456250084

#bind parm alpha fpreal
#bind parm gamma fpreal
#bind parm PENALTY_MIN fpreal
#bind parm PENALTY_MAX fpreal

#bind point P fpreal3
#bind prim primpoints int[] geo=ConstraintGeometry name=pts
#bind prim &C fpreal3 geo=ConstraintGeometry
#bind prim &lambda fpreal3 geo=ConstraintGeometry
#bind prim &penalty fpreal3 geo=ConstraintGeometry
#bind prim stiffness fpreal geo=ConstraintGeometry
#bind prim type_hash int geo=ConstraintGeometry
#bind prim &pointsupdated int geo=ConstraintGeometry

// Rough approximation to match Vellum
// Shared with solveConstraints.cl
const fpreal STIFFNESS_SCALE = 10.0f;

// From https://github.com/savant117/avbd-demo2d/blob/main/source/joint.cpp#L27
// Abusing #define variable naming to use @ bindings here
static void initialize_JointAVBD(
    const int _bound_idx,
    global int *_bound_primpoints,
    global int *_bound_primpoints_index,
    const int _bound_primpoints_length,
    const fpreal *_bound_P,
    const int _bound_P_length,
    const fpreal *_bound_C,
    const int _bound_C_length)
{
    const int pt0 = @primpoints.compAt(_bound_idx, 0);
    const int pt1 = @primpoints.compAt(_bound_idx, 1);

    const fpreal3 p0 = @P.getAt(pt0);
    const fpreal3 p1 = @P.getAt(pt1);
    
    // C is the difference in position between each connected point
    @C.set(p0 - p1);
}

// Dual update from AVBD
// From https://github.com/savant117/avbd-demo2d/blob/main/source/solver.cpp#L105
@KERNEL
{
    // Some constraints use initialization in the dual step
    switch (@type_hash)
    {
        case AVBD_SPRING:
        {
            // No initialization needed
            break;
        }
        case AVBD_JOINT:
        {
            // @ binding syntax isn't supported for _index array yet
            initialize_JointAVBD(@elemnum, @primpoints.data, _bound_primpoints_index, @primpoints.len,
                @P.data, @P.len, @C.data, @C.len);
            break;
        }
        default:
        {
            // Ignore non AVBD constraints
            return;
        }
    }
    
    // Warmstart the dual variables and penalty parameters (Eq. 19)
    @lambda.set(@lambda * @alpha * @gamma);
    
    // Penalty is safely clamped to a minimum and maximum value
    const fpreal3 penalty = clamp(@penalty * @gamma, @PENALTY_MIN, @PENALTY_MAX);
    
    // If it's not a hard constraint, we don't let the penalty exceed the material stiffness
    @penalty.set(min(penalty, @stiffness * STIFFNESS_SCALE));
    
    // Dual updating is normally 2x slower when run separately to solveConstraints
    // Luckily it can be merged into solveConstraints, as long as it happens after the last point update
    @pointsupdated.set(0);
}