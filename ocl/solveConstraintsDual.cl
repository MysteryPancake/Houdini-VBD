// Constraint hash IDs, generated by constraintHash() in VEX
#define AVBD_SPRING -1715226869

#bind parm beta fpreal
#bind parm PENALTY_MAX fpreal

#bind point P fpreal3
#bind prim &lambda fpreal geo=ConstraintGeometry
#bind prim &penalty fpreal geo=ConstraintGeometry
#bind prim restlength fpreal geo=ConstraintGeometry
#bind prim stiffness fpreal geo=ConstraintGeometry
#bind prim type_hash int geo=ConstraintGeometry
#bind prim primpoints int[] geo=ConstraintGeometry name=pts
#bind prim fmin fpreal geo=ConstraintGeometry
#bind prim fmax fpreal geo=ConstraintGeometry

// Shared with solveConstraints.cl
// From https://github.com/savant117/avbd-demo2d/blob/main/source/spring.cpp#L22
static inline fpreal computeConstraint_SpringAVBD(
    const int prim_id,
    global fpreal *_bound_P,
    global int *_bound_primpoints,
    global int *_bound_primpoints_index,
    int _bound_primpoints_length,
    const fpreal restlength)
{
    // #define hack to use @primpoints like normal
    const int pt0 = @primpoints.compAt(prim_id, 0);
    const int pt1 = @primpoints.compAt(prim_id, 1);
    
    const fpreal3 p0 = vload3(pt0, _bound_P);
    const fpreal3 p1 = vload3(pt1, _bound_P);
    
    return length(p0 - p1) - restlength;
}

// Dual update from AVBD
// From https://github.com/savant117/avbd-demo2d/blob/main/source/solver.cpp#L205
@KERNEL
{
    // Skip non AVBD constraints
    if (@type_hash != AVBD_SPRING) return;

    fpreal C = 0.0f;
    switch (@type_hash)
    {
        case AVBD_SPRING:
        {
            // Sadly there's no @ binding for _index arrays yet
            C = computeConstraint_SpringAVBD(@elemnum, @P.data,
                @primpoints.data, _bound_primpoints_index, @primpoints.len, @restlength);
            break;
        }
    }

    // Use lambda as 0 if it's not a hard constraint
    fpreal lambda = isinf(@stiffness) ? @lambda : 0.0f;
    
    // Update lambda (Eq 11)
    lambda = clamp(@penalty * C + lambda, @fmin, @fmax);
    @lambda.set(lambda);
    
    // Update the penalty parameter and clamp to material stiffness if we are within the force bounds (Eq. 16)
    if (lambda > @fmin && lambda < @fmax)
    {
        @penalty.set(min(@penalty + @beta * fabs(C), min(@PENALTY_MAX, @stiffness)));
    }
}